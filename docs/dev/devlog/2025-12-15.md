# 2025-12-15: Stack Refinement

## Focus

Finalizing v0 tech stack with emphasis on what transfers to production and what enables Haiku productivity.

## What Happened

Revisited ADR-002 (FastAPI + htmx) decision. Key realization: htmx patterns don't transfer to wgpu mental model, and the production client is "thin wrapper loading shaders" — renderer choice matters more than initially thought.

Discussion explored:
- htmx vs React vs Babylon.js
- wgpu scene graph options (Bevy, Vello, Dioxus)
- Remembered prior discussions: Dioxus (React-like in Rust), Babylon.js (WebGPU-first scene graph), Bevy (wgpu glue)

Landed on: **TypeScript renderer is a keeper**, not throwaway. The real architecture is:
- `GameState → pixels` contract enables renderer swapping
- Same interface supports CLI, React, Babylon, or future Bevy
- Engine/server abstractions transfer; renderer is swappable

## Decisions Made

- **ADR-008**: TypeScript renderer (supersedes ADR-002 htmx choice)
- **ADR-009**: Renderer-agnostic architecture (GameState/PlayerAction interface)

## Artifacts Created

- `docs/dev/gamestate-interface.md` — Interface spec with TypeScript types
- Updated `milestones.kb/a001-local-prototype.md` — Reflects new stack

## Next Session

**Continue a001 implementation with new stack:**

1. Set up uv workspace with packages: `engine`, `bot`, `server`
2. Set up Vite + React renderer package (React for widget ecosystem)
3. Implement GameState/PlayerAction types (Python dataclasses + TS interfaces)
4. Build engine with state serialization
5. Simple CLI renderer first (validates interface)
6. Then React web renderer

**Key discipline:** Renderer never imports engine internals. Engine computes `validActions`, renderer just displays them.
